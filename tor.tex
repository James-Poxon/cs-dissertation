%!TeX root=TermsOfReference.tex

\section{Background}
Virtualisation has been utilised by a number of industries for a long time now, with first iterations of virtual machines dating back to IBM in the 1960s \citep{pugh95}. System Virtual machines allow an operating system to emulate the function of a full operating system layered on top of a base operating system. Functionally, this allows multiple different logical 'computers' with varying operating systems to run on one physical computer. In most modern implementations, virtualisation requires software (known as a hypervisor) to manage and create the virtual machines.

Whilst I was on a year-long placement provided as part of a sandwich course at my university, I had the chance to work in an IT risk department at a reputable enterprise in Newcastle Upon Tyne. whilst working there I witnessed first hand, infrastructure and operations departments using virtualisation for much of the internally and externally facing server infrastructure, in what was an unwieldy and cumbrous use of scripts to update and install patches and dependencies across a multitude of systems. This resulted in a number of incidents where systems had to be pulled down in order to update the Operating Systems of individual virtual machines. These methods often caused unnecessary down time for systems, resulting in substantial risk for the business. Furthermore, this method often put a substantial stress on the hardware of these systems, with hardware boxes often running at full resource potential under heavy load, and whilst these boxes were designed to withstand these kinds of loads, it still affected the longevity of the hardware.

In recent years there has been research into the use of containers instead of virtual machines for various operations across computing industries \citep{watanda19}. Containers are different from virtual machines in that they run on the base OS, and don't require a secondary emulated operating system to be managed by a hypervisor. This is a benefit as it reduces the resources \citep{joy15} used by each instance. Overall, containers are a more lightweight and efficient system, that are easier to keep up to date. Whilst research has claim in displaying the benefits of containerisation, much of the server infrastructure of enterprise remains reliant on Virtualisation, not Containerisation.

I have also had the opportunity to partake in gatherings held by CoTech, a network of tech co-operatives that meet semi-regularly to discuss various tech related topics. Whilst I was there, it was discussed that a large portion of these small enterprises used Docker, a system for packaging and deploying containers, to develop applications for their clients.

There is historical research that compares virtualisation and containerisation for other technical applications, for example \citep{dua14} compares the two methods inside the context of PaaS (Platform as a service), which is similar to co-techs use of Docker. It seems that the application for containerisation has been realised as early as 2014 when it is being applied to the development and hosting of applications, but not as much when talking about the running of wider server infrastructure. This is further supported by research from '451 Research' who in 2017 estimated a compound annual growth rate of 40\% for containers in 2020 \citep{451}, suggesting a coming paradigm shift from virtualisation to containerisation.

\section{Proposed Work}
\label{proposed}
I plan to do similar work to the studies I have already mentioned \citep{joy15}, \citep{dua14}, but instead focus this work on my own context and my own interest in Operating Systems and Server Infrastructure. I have experience with running headless servers on virtual machines already, through the Advanced Operating Systems module I did in my second year of study at Northumbria University. I plan to use Linux (ubuntu server) as the base operating system for my virtual machines, and plan to host a full working topology of servers, including a DNS architecture with primary and secondary servers, a web-server architecture that includes HTTP (Apache) servers, NFS servers and MySQL servers. The idea behind this is to create as realistic a topology as possible, and to ensure a decent level of communication and work between the individual servers.

\section{Aims and Objectives}
There should only be one or two aims
\subsection{Aims}
\begin{quote}
	To show how \LaTeX\ and tools can be used to write a dissertation
\end{quote}

\subsection{Objectives}
Your objective list is a series of measurable objectives, can you tick each one off as \emph{done}?  I usually expect between 8 and 12 objectives

The \textbf{enumerate} environment is useful here for generating a numbered list.   You can put \mintinline{tex}{\label{}} commands in with a keyword \mintinline{tex}{\label{understand-problem}} and then refer to the label with a \mintinline{tex}{\ref{understand-problem}} command, it puts the number of the objective in the text
\begin{tcblisting}{ }
	See objective \ref{understand-problem}
\end{tcblisting}
\begin{enumerate}
	\item \textbf{Classify the problem domain}\label{understand-problem}  this is where you develop an understanding of the nature of the problem/project
	\item \textbf{Identify Techniques to solve}  What Algorithms are you to use, how is a database structured,
	\item \textbf{Select tools to use}  What languages, software, hardware; are you using?
	\item \textbf{Design the system to be build}\label{write-code}  Its requirements, the \textbf{test plan}, the architecture (Layer model/Model-View-Controller)
	\item \textbf{Build the system}  I'd include testing here, as the result is a \emph{working wywtem}
\end{enumerate}

\section{Skills}
This is where you can cover the skills you have relevant to the project and the new skills you are going to acquire during the project.
\begin{enumerate}
	\item Programming in C, see module KFxxx
	\item Hardware Design
\end{enumerate}

\section{Resources}
This is an important section, it lists the hardware and software you are going to need for the project.

\subsection{Hardware}
For Hardware this is more critical, as we need to identify any hardware we have, or that you are going to buy.  We do have an ordering mechanism in the Department, but time and budget are critical constraints here.

\subsection{Software}
In the case of software, there isn't usually an issue, unless you're needing huge amounts of run-time (we don't have a super-computer handy).

\section{Structure and Contents of the Report}
Here you set out the likely chapters you will have in your report.  Usually each objective lends itself to one or more chapters.  You can refer back to the objectives set.
\subsection{Report Structure}

\paragraph{Introduction}  Sets out the background and motivation for the project.  Summarises the work done, the results, the conclusions, and the recommendations for future work.  It is a one chapter summary of the \emph{entire} project.

\paragraph{Defining the problem}  Objective \ref{understand-problem} requires a precise definition of the problem you are solving.  Don't forget to reference good source material  See section \ref{proposed}.

\paragraph{Possible Solutions} Discuss the possible solutions, compare the
alternatives, and select the one to use for the  implementation.

\subsection{List of Appendices}
What Appendices you will include.  A copy of the TOR should be the first, followed by the Ethics form and the Risk Assessment.

Others might include design documentation, code listings, tables of results (if too large to include in the main text).

\section{Marking Scheme}
The marking scheme sets out what criteria we are going to use for the project.

\paragraph{Project Type} General Computing or Software Engineering projects

\paragraph{Project Report}  State which chapters constitute the \emph{Analysis}, the \emph{Synthesis}, and the \emph{Evaluation}.  This help me when marking to know when to stop reading one section and put a mark down for it.

\paragraph{Product}  List the deliverables that make up the \emph{Product}.  Code, design, requirements specifications, test plans, etc.

For the \emph{Fitness for Purpose} and \emph{Build Quality}  list the critera used to asses the product by

\subparagraph{Fitness for Purpose}~
\begin{itemize}
	\item meet requirements identified
	\item other appropriate measures
\end{itemize}

\subparagraph{Build Quality}~
\begin{itemize}
	\item Requirements specification and analysis
	\item Design Specification
	\item Code quality
	\item Test plan and Results
\end{itemize}

\clearpage

\section{Project Plan}
\noindent
\rotatebox{90}{\input{Gantt}}
